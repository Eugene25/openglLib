#include <GLTools.h>	// OpenGL toolkit
#include <GLMatrixStack.h>
#include <GLFrame.h>
#include <GLFrustum.h>
#include <GLBatch.h>
#include <GLGeometryTransform.h>
#include <math.h>
#ifdef __APPLE__
#include <glut/glut.h>
#else
#define FREEGLUT_STATIC
#include <GL/glut.h>
#endif
/////////////////////////////////////////////////////////////////////////////////
// An assortment of needed classes
GLShaderManager		shaderManager;
GLMatrixStack		modelViewMatrix;
GLMatrixStack		projectionMatrix;
GLFrame				cameraFrame;
GLFrustum			viewFrustum;
GLBatch				cubeBatch;
GLBatch				floorBatch;
GLBatch				topBlock;
GLBatch				frontBlock;
GLBatch				leftBlock;
GLGeometryTransform	transformPipeline;
M3DMatrix44f		shadowMatrix;
// Keep track of effects step
int nStep = 0;
// Lighting data
GLfloat lightAmbient[] = { 0.2f, 0.2f, 0.2f, 1.0f };
GLfloat lightDiffuse[] = { 0.7f, 0.7f, 0.7f, 1.0f };
GLfloat lightSpecular[] = { 0.9f, 0.9f, 0.9f };
GLfloat vLightPos[] = { -8.0f, 20.0f, 100.0f, 1.0f };
GLuint textures[4];



void MakeFloor(GLBatch& floorBatch)
{
	GLfloat x = 5.0f;
	GLfloat y = -1.0f;
	floorBatch.Begin(GL_TRIANGLE_FAN, 4, 1);
	floorBatch.MultiTexCoord2f(0, 0.0f, 0.0f);
	floorBatch.Vertex3f(-0.5f, -0.5, 0);
	floorBatch.MultiTexCoord2f(0, 1.0f, 0.0f);
	floorBatch.Vertex3f(-0.5f, 0.5f, 0);
	floorBatch.MultiTexCoord2f(0, 1.0f, 1.0f);
	floorBatch.Vertex3f(0.5f, 0.5f, 0);
	floorBatch.MultiTexCoord2f(0, 0.0f, 1.0f);
	floorBatch.Vertex3f(0.5f, -0.5f, 0);
	floorBatch.End();

}
///////////////////////////////////////////////////////////////////////////////
// This function does any needed initialization on the rendering context. 
// This is the first opportunity to do any OpenGL related tasks.
void SetupRC()
{
	GLbyte *pBytes;
	GLint nWidth, nHeight, nComponents;
	GLenum format;
 
	// Black background
	glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
	glEnable(GL_DEPTH_TEST);
	glLineWidth(2.5f);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);

	MakeFloor(floorBatch);
	
	// Load up four textures  
	glGenTextures(4, textures);

	// Wood floor
	pBytes = gltReadTGABits("car.tga", &nWidth, &nHeight, &nComponents, &format);
	glBindTexture(GL_TEXTURE_2D, textures[0]);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexImage2D(GL_TEXTURE_2D, 0, nComponents, nWidth, nHeight, 0,
		format, GL_UNSIGNED_BYTE, pBytes);
	free(pBytes);

}

void RenderFloor(void)
{
	switch (nStep)
	{
		// Wire frame
	case 0:
		glEnable(GL_BLEND);
		glEnable(GL_LINE_SMOOTH);
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
		glDisable(GL_CULL_FACE);

		glBegin(GL_POLYGON);
		glTexCoord2f(0, 0);
		glVertex2f(-0.5, -0.5);
		glTexCoord2f(0, 1.0f);
		glVertex2f(0.5, -0.5);
		glTexCoord2f(1.0f, 1.0f);
		glVertex2f(0.5, 0.5);
		glTexCoord2f(1.0f, 0);
		glVertex2f(-0.5, 0.5);
		glEnd();

		break;
		// Wire frame, but not the back side.. and only where stencil == 0
	case 1:
		glEnable(GL_TEXTURE_2D);
		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
		glBindTexture(GL_TEXTURE_2D, textures[0]);

		glBegin(GL_POLYGON);
		glTexCoord2f(0, 0);
		glVertex2f(-0.5, -0.5);
		glTexCoord2f(0, 1.0f);
		glVertex2f(0.5, -0.5);
		glTexCoord2f(1.0f, 1.0f);
		glVertex2f(0.5, 0.5);
		glTexCoord2f(1.0f, 0);
		glVertex2f(-0.5, 0.5);
		glEnd();
		break;
	default:
		break;
	}


	// Draw the floor
//	floorBatch.Draw();
	// Put everything back
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	glEnable(GL_CULL_FACE);
	glDisable(GL_BLEND);
	glDisable(GL_LINE_SMOOTH);
	glDisable(GL_STENCIL_TEST);
	glDisable(GL_TEXTURE_2D);
}
///////////////////////////////////////////////////////////////////////////////
// Called to draw scene
void RenderScene(void)
{
	// Clear the window with current clearing color
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
	modelViewMatrix.PushMatrix();

	RenderFloor();

	modelViewMatrix.PopMatrix();
	// Flush drawing commands
	glutSwapBuffers();
}

void KeyPressFunc(unsigned char key, int x, int y)
{
	if (key == 32)
	{
		nStep++;
		if (nStep > 2)
			nStep = 0;
	}
	// Refresh the Window
	glutPostRedisplay();
}

int main(int argc, char* argv[])
{
	gltSetWorkingDirectory(argv[0]);

	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH | GLUT_STENCIL);
	glutInitWindowSize(800, 600);
	glutCreateWindow("3D Effects Demo");

	GLenum err = glewInit();
	if (GLEW_OK != err)
	{
		//Problem: glewInit failed, something is seriously wrong.
		fprintf(stderr, "Error: %s\n", glewGetErrorString(err));
		return 1;
	}

	glutKeyboardFunc(KeyPressFunc);
	glutDisplayFunc(RenderScene);
	SetupRC();
	glutMainLoop();
	glDeleteTextures(4, textures);
	return 0;
}
